package org.ardestan.generator;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintStream;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.Vector;

import javax.swing.JOptionPane;

import org.ardestan.arclass.ARClassDatabase;
import org.ardestan.arclass.ARClassInfo;
import org.ardestan.gui.ArdestanIDE;
import org.ardestan.gui.MainWindow;
import org.ardestan.gui.Message;
import org.ardestan.json.JsonProgramLoader;
import org.ardestan.misc.ARFileConst;


/**
 * @author hnishino
 * 
 */
public class ArduinoSourceCodeGenerator 
{

		
	protected int seqObjectID;

	protected Map<Integer, ARInstanceInfo> idToInstanceInfo; 
	
	protected int	numOfLoadBangObjects;
	protected int 	numOfPollingObjects;
	protected int	numOfEventSchedulingObjects;
	protected int	numOfTimerEvents = 32;
	protected int	numOfInitialDelayEventPoolSize = 16;
	
	
	protected Map<String, Integer> instanceNameToID;
	protected Map<String, Integer> structNameToCount;
	
	protected Set<String> libHeaderFilenames;
	protected Set<String> libCppFilenames;

	protected int seqConnectionID;
	protected Map<Integer, Integer> 					idToConnectionID;
	protected Map<Integer, Vector<ARConnectionInfo> > 	idToConnections;
	
	protected int totalNumOfInlets;
	protected int maxArgCount;
	
	protected Set<String> symIDs;
	
	protected boolean serialInObjectFound;
	
	public static final String GENERATED_HEADER_FILENAME 	= "AutoGeneratedHeader.h";
	public static final String GENERATED_IDS_FILENAME  		= "ArdestanIDs.h";

	public static final String SERIAL_IN_CLASSNAME			= "serial_in";

/*
 *
 *typedef union {
    uint16_t i;
    ARConnection c;
  } Conv;
 Serial.begin(9600);
  {
     for (int i = 0; i < sizeof(g_connections) / sizeof(g_connections[0]); i++){
        Conv v = { pgm_read_word(g_connections + i)};
        Serial.print(i);
        Serial.print(":");
        Serial.print(v.i);
        Serial.print("->");
        Serial.print(v.c.outlet_no);
        Serial.print(",");
        Serial.print(v.c.dest_obj_id);
        Serial.print(",");
        Serial.println(v.c.inlet_no);
        
     }

   // while(true)delay(1000);
  }
//  return;
 */
	/**
	 * @param ardestanSourceCode
	 * @param arduinoProjectPath
	 * @throws IOException
	 */
	public static void generate(String ardestanSourceCode, 
								String arduinoProjectPath, boolean usePROGMEMforOutlets, boolean usePROGMEMforConnections) throws IOException
	{
		
		//load the Ardestan code.
		JsonProgramLoader loader = new JsonProgramLoader();
		loader.loadFromFile(ardestanSourceCode);
		
		//build a model
		ArduinoSourceCodeGenerator gen = new ArduinoSourceCodeGenerator();
		gen.buildModel(loader.getInstances(), loader.getConnections());

		//generate the source/header files.
		File f = new File(arduinoProjectPath);
		
		if (!f.exists()) {
			f.mkdirs();
		}
		
		String projectName = f.getName();
		String inoFilename = projectName + ".ino";
		
		String headerFilename = GENERATED_HEADER_FILENAME;
		String symbolIDsFilename = GENERATED_IDS_FILENAME;

		String headerFilenameFullPath 	= arduinoProjectPath + File.separator + headerFilename;
		String symbolIDsFilenameFullPath= arduinoProjectPath + File.separator + symbolIDsFilename;
		String inoFilenameFullPath		= arduinoProjectPath + File.separator + inoFilename;
		
		gen.generateFiles(headerFilenameFullPath, symbolIDsFilenameFullPath, inoFilenameFullPath, usePROGMEMforOutlets, usePROGMEMforConnections);
		
		//copy the necessary header/source files of the objects.
		gen.copyLibraryFiles(arduinoProjectPath);

		//copy the Ardestan framework (header/source) files.
		gen.copyArdestanFrameworkFiles(arduinoProjectPath);
	}
	

	/**
	 * @param projectPath
	 * @throws IOException
	 */
	public void copyArdestanFrameworkFiles(String projectPath) throws IOException
	{
		this.copyFileFromResourceToDiretory(ARFileConst.DEFAULT_FRAMEWORK_HEADER_FILE_RESOURCE_NAME	, projectPath + File.separator + "Ardestan.h");
		this.copyFileFromResourceToDiretory(ARFileConst.DEFAULT_FRAMEWORK_CPP_FILE_RESOURCE_NAME	, projectPath + File.separator + "Ardestan.ino");
	}
	
	/**
	 * @param resourceName
	 * @param ProjectPath
	 * @throws IOException
	 */
	public void copyFileFromResourceToDiretory(String resourceName, String destinationFilename) throws IOException
	{
		InputStream is = ClassLoader.getSystemResourceAsStream(resourceName);

		FileSystem fs = FileSystems.getDefault();
		Path dst = fs.getPath(destinationFilename);
		
		if (Files.exists(dst)) {
			Files.delete(dst);
		}
		
		Message.println("copying the resource:" + resourceName + " as the file:" + dst.getFileName());

		Files.copy(is, dst);
		
		return;
	}

	/**
	 * @param classCodeStoragePath
	 * @param projectPah
	 */
	public void copyLibraryFiles(String projectPath) throws IOException
	{
		//copy the lib headers.
		for (String filename: libHeaderFilenames) {
			
			//the destination path
			File dst = null;
			
			//check if the filename is given as an absolute path.
			File tmp = new File(filename);
			if (tmp.isAbsolute()) {
				dst = new File(projectPath + File.separator + tmp.getName());
			}
			else {
				dst = new File(projectPath + File.separator + filename);
			}
			
			
			if (dst.exists()) {
				Files.delete(dst.toPath());
			}
				
			if (!tmp.isAbsolute()) {
				String headerResourceName = ARFileConst.DEFAULT_OBJECT_HEADER_RESOURCE_PATH + "/" + filename;
				this.copyFileFromResourceToDiretory(headerResourceName, dst.getCanonicalPath());
			}
			else {
				Path srcPath = Paths.get(filename);
				Path dstPath = Paths.get(dst.getAbsolutePath());
				Files.copy(srcPath, dstPath);
			}
		}
		
		//copy the cpp/ino files.
		for (String filename: libCppFilenames) {
			
			File tmp = new File(filename);
			File dst = null;
			
			//replace the extension if it is not 'ino' (we have lots of cpp files).
			String inoExtension  = ARFileConst.ARDUINO_INO_FILE_EXTENSION_WITH_DOT;
			String inoFilename = tmp.getName();
			if (!filename.endsWith(inoExtension)) {
				inoFilename = inoFilename.substring(0, inoFilename.length() - inoExtension.length()) + inoExtension;
			}
			
			//check if the filename is given as an absolute path.
//			if (tmp.isAbsolute()) {
//				dst = new File(projectPath + File.separator + tmp.getName());
//			}
//			else {
				dst = new File(projectPath + File.separator + inoFilename);
//			}
						
			if (dst.exists()) {
				Files.delete(dst.toPath());
			}

			if (!tmp.isAbsolute()) {
				String cppResourceName = ARFileConst.DEFAULT_OBJECT_CPP_RESOURCE_PATH + "/" + filename;
				this.copyFileFromResourceToDiretory(cppResourceName, dst.getCanonicalPath());
			}
			else {
				Path srcPath = Paths.get(filename);
				Path dstPath = Paths.get(dst.getAbsolutePath());
				Files.copy(srcPath, dstPath);
			}
			
		}
	}
	

	/**
	 * @param headerFilenameFullPath
	 * @param symbolIDsFilenameFullPath
	 * @param inoFilenameFullPath
	 * @throws IOException
	 */
	public void generateFiles(String headerFilenameFullPath, String symbolIDsFilenameFullPath, String inoFilenameFullPath, boolean usePROGMEMforOutlets, boolean usePROGMEMforConnections) throws IOException
	{
		//the auto generated header file.
		FileOutputStream 	fos 	= null;
		PrintStream			out		= null;
		
		try {
			fos = new FileOutputStream(headerFilenameFullPath);
			out = new PrintStream(fos);
			this.generateHeaderFile(out, usePROGMEMforOutlets, usePROGMEMforConnections);
		}
		finally {
			if (out != null) {
				out.close();
			}
			if (fos != null) {
				fos.close();
			}
		}
		
		//the symbol IDs header file.
		try {
			fos = new FileOutputStream(symbolIDsFilenameFullPath);
			out = new PrintStream(fos);
			this.generateSymbolIDs(out);
		}
		finally {
			if (out != null) {
				out.close();
			}
			if (fos != null) {
				fos.close();
			}
		}
		
		//the ino file.
		try {
			fos = new FileOutputStream(inoFilenameFullPath);
			out = new PrintStream(fos);
			
			File f1 = new File(headerFilenameFullPath);
			File f2 = new File(symbolIDsFilenameFullPath);
			this.generateInoFile(out, f1.getName(), f2.getName(), usePROGMEMforOutlets, usePROGMEMforConnections);
		}
		finally {
			if (out != null) {
				out.close();
			}
			if (fos != null) {
				fos.close();
			}
			
		}
		return;
	}
	
	
	/**
	 * 
	 */
	public void resetSymIDs()
	{
		this.symIDs = new TreeSet<String>();
		
		this.symIDs.add("ID_BANG");
		this.symIDs.add("ID_LOADBANG");
		this.symIDs.add("ID_POLL");
		this.symIDs.add("ID_TIMER_CALLBACK");
		

	}
	
	/**
	 * @param symbol
	 */
	public void addSymol(String symbol)
	{
		symbol = symbol.trim();
		String symID = ArgType.convertToSymID(symbol);
		this.symIDs.add(symID);
		return;
	}
	
	/**
	 * @throws IOException
	 */
	public void generateSymbolIDs(PrintStream out) throws IOException
	{
		for (ARInstanceInfo i : idToInstanceInfo.values()) {
			String[] types  = i.getArgTypes();
			String[] values = i.getArgValues(); 
			
			for (int idx = 0; idx < types.length; idx++) {
				if (ArgType.stringToEnum(types[idx]) != ArgType.SYM_ID) {
					continue;
				}
				String symID = ArgType.convertToSymID(values[idx]);
				if (!this.symIDs.contains(symID)) {
					this.symIDs.add(symID);
				}
				
			}
		}
		
		out.println("#ifndef __ARDESTAN_SYM_IDS__");
		out.println("#define __ARDESTAN_SYM_IDS__");
		out.println();
		
		String lastSymID = null;
		
		out.println("enum ARSymID: int32_t");
		out.println("{");
		
		out.println("    ID_INVALID_SYMBOL=-1,");
		out.println("    ID_BANG=0,"); //we want to keep bang's id value = 0;

		for (String symID: this.symIDs) {
			//we already have ID_BANG.
			if (symID.equals("ID_BANG")) {
				continue;
			}
			out.println("    " + symID + ",");
			lastSymID = symID;
		}
		out.println("};");
		
		out.println();
		out.println("#define MAX_ARSYMID ARSymID::" + lastSymID);
	
		out.println();
		
		out.println("#endif");
	}
	

	
	/**
	 * @param out
	 * @param headerFilename
	 * @throws IOException
	 */
	public void generateInoFile	(PrintStream out, String headerFilename, String symIDsFilename, boolean usePROGMEMforOutlets, boolean usePROGMEMforConnections) throws IOException
	{
		this.generateSourceFile(out, headerFilename, symIDsFilename, "ino", usePROGMEMforOutlets, usePROGMEMforConnections);
	}

	
	/**
	 * @param inoFilename
	 * @param out
	 * @throws IOException
	 */
	public void generateSourceFile	(PrintStream out, String headerFilename, String symIDsFilename, String extension, boolean usePROGMEMforOutlets, boolean usePROGMEMforConnections) throws IOException
	{
		out.println("#include <stdio.h>");
		out.println("#include <stdlib.h>");
		out.println("#include <stdint.h>");
		out.println("#include <string.h>");
		
		if (usePROGMEMforConnections) {
			out.println();
			out.println("#include <avr/pgmspace.h>");
			out.println();
		}
		
		out.println();
		out.println("#include \"" + symIDsFilename + "\"");
		out.println("#include \"" + headerFilename + "\"");
		out.println("#include \"Ardestan.h\"");
		out.println();
		
		for (String h: libHeaderFilenames){
			out.println("#include \"" + h + "\"");
		}
		out.println();

		Set<String> keySet = structNameToCount.keySet();
		int keyCnt = 0;
		int keySetSize = keySet.size();
		
		if (keySetSize == 0) {
			out.println("constexpr long REQUIRED_MEMORY_SPACE_FOR_OBJECTS = 0;");
		}
		else {
			out.println("constexpr long REQUIRED_MEMORY_SPACE_FOR_OBJECTS =");
			for (String s: keySet){
				int cnt = structNameToCount.get(s);
				out.print("    sizeof(" + s + ") * " + cnt);
				
				keyCnt++;
				if (keyCnt < keySetSize){
					out.println(" +");
				}
			}			
			out.println(";"); 
		}

		out.println();		
		out.println("uint8_t        g_memory_space[REQUIRED_MEMORY_SPACE_FOR_OBJECTS];");
		out.println();		
		out.println("uint32_t       g_timer_callback_timestamp[NUM_OF_EVENT_SCHEDULING_OBJECTS];");
		out.println();		
		out.println("ARObject       g_objects[" + seqObjectID + "];");
		out.println("ARValue        g_inlets[" + totalNumOfInlets + "];");
		out.println();
		

		//--------------------------------------------------------------
		//generate the g_outlets array.
		
		if (usePROGMEMforOutlets) {
			out.println("const uint16_t g_outlets[" + seqObjectID + "] PROGMEM = {");		
			
			for (int i = 0; i < idToInstanceInfo.size() ; i++){
				int connectionID = idToConnectionID.get(i) ;
				int numOfConnections = idToConnections.get(i).size();

				//arduino is little endian and the definition of ARConnection utilizes bit fields,
				//so the below bit shift is okay (the order of the fields will be reversed in the little endian platform).
				short uint16Value = (short)( ((numOfConnections & 0x3F) << 10) | (connectionID & 0x3FF) );
				String hex = "0x" + Integer.toHexString(uint16Value & 0xFFFF);
				out.println(hex + ", // " + hex + " <- 16 bits (little endian) that cosists of connection_id:10, num_of_connections:6 (" + connectionID + ", " + numOfConnections  + ")");
			}
			out.println("};");
		}
		else {
			out.println("AROutlets      g_outlets[" + seqObjectID + "] = {");		
			for (int i = 0; i < idToInstanceInfo.size() ; i++){
				out.println("    {" + idToConnectionID.get(i) + ", " + idToConnections.get(i).size() + "},");
			}
			out.println("};");
		}
		//--------------------------------------------------------------
		//generate the g_connections array.
		out.println();

		if (usePROGMEMforConnections) {
			out.println("const uint16_t g_connections[" + seqConnectionID + "] PROGMEM = {");	
		}
		else {
			out.println("ARConnection   g_connections[" + seqConnectionID + "] = {");
		}
		
		for (int i = 0; i < idToInstanceInfo.size(); i++){
			
			Vector<ARConnectionInfo> v = idToConnections.get(i);
			for (int j = 0; j < v.size(); j++){
				ARConnectionInfo info = v.get(j);
				if (!instanceNameToID.containsKey(info.getDest())) {
					throw new IOException("the instance :" + info.getDest() + " doesn't exist in the program.");
				}
				
				if (usePROGMEMforConnections) {
					int tmp = instanceNameToID.get(info.getDest());;
					short outletNo 	= (short)info.getOutletNo();
					short inletNo  	= (short)info.getInletNo();
					short destId	= (short)tmp;
					
					//arduino is little endian and the definition of ARConnection utilizes bit fields,
					//so the below bit shift is okay (the order of the fields will be reversed in the little endian platform).
					short uint16Value = (short)( ((inletNo & 0x07) << 13) | ((destId & 0x3FF) << 3) | (outletNo & 0x07) );
					String hex = "0x" + Integer.toHexString(uint16Value & 0xFFFF);
					out.println(hex + ", // " + hex + " <- 16 bits (little endian) that cosists of outlet_no:3 , dest_object_id:10, inlet_no:3 (" + info.getOutletNo() + ", " + destId + ", " + info.getInletNo() + ")");
				}
				else {
					int destId = instanceNameToID.get(info.getDest());
					out.println("    {" + info.getOutletNo() + ", " + destId + ", " + info.getInletNo() + "}," );
				}
			}
		}
		out.println("};");
		out.println();

		out.println("void setup(void)");
		out.println("{");
		out.println("    uint8_t *p_alloc = g_memory_space;");
		out.println("    ARValue *p_inlet = g_inlets;");
		out.println();		
		out.println("    ARStr   *p_arstr = NULL;");
		out.println();		

		if (maxArgCount > 0) {
			out.println("    ARMessageType argTypes [" + maxArgCount + "];");
			out.println("    ARValue       argValues[" + maxArgCount + "];");
		}
		
		for (int i = 0; i < idToInstanceInfo.size(); i++){
			out.println();		
			ARInstanceInfo info = idToInstanceInfo.get(i);
			String 	funcNameInit 	= info.getFuncNameInit();

			String[] argTypes 		= info.getArgTypes();
			String[] argValues		= info.getArgValues();

			//initialize an ARObject.
			if (info.getARClassInfo().isOnlyLeftMostInletHot()) {
				out.println("    g_objects[" + i + "].init(p_alloc, " + info.getFuncNameTrigger() + ", " + info.getNumOfInlets() + ", p_inlet);");
			}
			else {
				out.println("    g_objects[" + i + "].init(p_alloc, " + info.getFuncNameTrigger() + ", " + info.getNumOfInlets() + ", p_inlet, false);");					
			}

			//argc = 0;
			if (info.getArgc() == 0){
				out.println("    " + funcNameInit + "(&(g_objects[" + i + "]), p_alloc, 0, NULL, NULL);");
				if (info.getStructName() != null){
					out.println("    p_alloc += sizeof(" + info.getStructName() + ");");
				}
				out.println("    p_inlet += " + info.getNumOfInlets() + ";");
				continue;
			}
			
			//argc > 0
			for (int j = 0; j < argTypes.length; j++){
				if (ArgType.Str_Parameter.equals(argTypes[j])) {
					MainWindow win = ArdestanIDE.getMainWindow();
					
					JOptionPane.showMessageDialog(win.getFrame(), "Invalid patch: a patch must not have a parameter to be compiled. the build process was aborted.");
					throw new IOException("invalid patch: a patch must not have a parameter to be compiled. the build process was aborted.");
				}
				out.println("    argTypes [" + j + "] = ARMessageType::" + argTypes[j] + ";");
				if (ArgType.Str_STRING.equals(argTypes[j])) {
					out.println("    p_arstr = ARObject::createString(" + argValues[j] + ", REF_CNT_CONST_STRING);");
				}
				out.println("    " + ArgType.convertToARValueAssignment(j, argTypes[j], argValues[j]));
			}
			out.println("    " + funcNameInit + "(&(g_objects[" + i + "]), p_alloc, " + info.getArgc() + ", argTypes, argValues);");
			if (info.getStructName() != null){
				out.println("    p_alloc += sizeof(" + info.getStructName() + ");");
			}
			out.println("    p_inlet += " + info.getNumOfInlets() + ";");

		}
		
		out.println();
		out.println();
		out.println("    ARValue sym_loadbang;");
		out.println("    sym_loadbang.sym_id = ID_LOADBANG;");
		out.println();
		out.println("    //initialize the timer callback timestamp to __UINT32_MAX__ (0xFFFFFFFF)");
		out.println("    memset(g_timer_callback_timestamp, 0xFF, sizeof(g_timer_callback_timestamp));");
		out.println();

		out.println("    set_now(millis());");
		out.println();

		out.println("    //trigger loadbang objects.");
		out.println("    for (int i = NUM_OF_POLLING_OBJECTS + NUM_OF_EVENT_SCHEDULING_OBJECTS; i < NUM_OF_POLLING_OBJECTS + NUM_OF_EVENT_SCHEDULING_OBJECTS + NUM_OF_LOADBANG_OBJECTS; i++){");
		out.println("        g_objects[i].input(0, ARMessageType::SYM_ID, sym_loadbang);");
		out.println("    }");		
		out.println();

		out.println("    set_now(millis());");
		out.println();
		
		out.println("}");

		out.println();
		out.println();
		out.println("void loop(void)");
		out.println("{");
		out.println("    ARValue sym_polling;");
		out.println("    sym_polling.sym_id = ID_POLL;");
		out.println();
		out.println("    //trigger the polling objects every cycle.");
		out.println("    for (int i = NUM_OF_EVENT_SCHEDULING_OBJECTS; i < NUM_OF_EVENT_SCHEDULING_OBJECTS + NUM_OF_POLLING_OBJECTS; i++){");
		out.println("        g_objects[i].input(0, ARMessageType::SYM_ID, sym_polling);");
		out.println("    }");
		out.println();
		out.println("    //process the scheduled timer callack events.");
		out.println("    uint32_t current_logical_time;");
		out.println("    uint32_t real_time = millis();");
		out.println();
		//if there is any serial input object, handle it here.
		if (serialInObjectFound) {
			out.println("    //handle the serial input.");
			out.println("    serial_in_queue_handle_serial_input();");
		}
		out.println();
		out.println("    #if (NUM_OF_EVENT_SCHEDULING_OBJECTS > 0)");
		out.println("        //process scheduled events.");
		out.println("        current_logical_time = process_scheduled_timer_callback(real_time);");
		out.println("    #else");
		out.println("        //if the time has been wound back (the time counter overflow),");
		out.println("        //just halt the system.");
		out.println("        if (real_time < now()){");
		out.println("            current_logical_time = __UINT32_MAX__;");
		out.println("        }");
		out.println("        else {");
		out.println("            set_now(real_time);");
		out.println("            current_logical_time = real_time;");
		out.println("        }");
		out.println("    #endif");
		out.println();		
		out.println("    //halt the system if the time has been reached.");
		out.println("    while(current_logical_time == __UINT32_MAX__);");
		out.println();
		out.println("}");

	}
	
	/**
	 * generate the source file for the Arduino.
	 * @param filename
	 */
	public void generateHeaderFile(PrintStream out, boolean usePROGMEMforOutlets, boolean usePROGMEMforConnections) throws IOException
	{
		out.println("#ifndef __ARDESTAN_AUTO_GENERATED_HEADER_FILE__");
		out.println("#define __ARDESTAN_AUTO_GENERATED_HEADER_FILE__");
		out.println();

		if (usePROGMEMforOutlets) {
			out.println("#define USE_PROGMEM_FOR_OUTLETS");			
		}
		if (usePROGMEMforConnections) {
			out.println("#define USE_PROGMEM_FOR_CONNECTIONS");
		}
		if (usePROGMEMforOutlets && usePROGMEMforConnections) {
			out.println();
		}
		
		out.println("#define NUM_OF_POLLING_OBJECTS  (" + numOfPollingObjects + ")");
		out.println("#define NUM_OF_EVENT_SCHEDULING_OBJECTS (" + numOfEventSchedulingObjects + ")");
		out.println("#define NUM_OF_LOADBANG_OBJECTS (" + numOfLoadBangObjects + ")");
		
		
		out.println();
		
		out.println("#endif");
		
	}
	
	

	/**
	 * @param className
	 */
	protected void incrementStructNameCount(String structName)
	{
		//some objects don't have any associated structure.
		if (structName == null){
			return;
		}
		
		int count = 0;
		if (structNameToCount.containsKey(structName) == true){
			count = structNameToCount.get(structName);
		}
		
		count++;
		
		structNameToCount.put(structName, count);
		return;
	}
	
	/**
	 * @param newInstance
	 */
	protected void updateMaxArgLength(ARInstanceInfo newInstance)
	{
		int argc = newInstance.getArgc();
		if (maxArgCount < argc){
			maxArgCount = argc;
		}
	}
	
	/**
	 * 
	 */
	public void modifyIfOperatorObject(ARInstanceInfo info)
	{
		String cname = info.getARClassInfo().getARClassName();
		if (cname.equals("==")) {
			convertToBopObject(info, ArBinOpID.EQ);
		}
		else if (cname.equals("!=")){
			convertToBopObject(info, ArBinOpID.NEQ);			
		}
		else if (cname.equals("<")){
			convertToBopObject(info, ArBinOpID.LT);			
		}
		else if (cname.equals("<=")){
			convertToBopObject(info, ArBinOpID.LTEQ);			
		}
		else if (cname.equals(">")){
			convertToBopObject(info, ArBinOpID.GT);			
		}
		else if (cname.equals(">=")){
			convertToBopObject(info, ArBinOpID.GTEQ);			
		}
		else if (cname.equals("&&")){
			convertToBopObject(info, ArBinOpID.LAND);			
		}
		else if (cname.equals("||")){
			convertToBopObject(info, ArBinOpID.LOR);			
		}
		else if (cname.equals("+")){
			convertToBopObject(info, ArBinOpID.ADD);			
		}
		else if (cname.equals("-")){
			convertToBopObject(info, ArBinOpID.SUB);			
		}
		else if (cname.equals("*")){
			convertToBopObject(info, ArBinOpID.MUL);			
		}
		else if (cname.equals("/")){
			convertToBopObject(info, ArBinOpID.DIV);			
		}
		else if (cname.equals("%")){
			convertToBopObject(info, ArBinOpID.MOD);			
		}
	}
	
	/**
	 * @param argTypes
	 * @param symbol
	 * @return
	 */
	public void convertToBopObject(ARInstanceInfo info, int binOpID)
	{
		
		String[] argTypes = info.getArgTypes();
		String[] newArgTypes = new String[argTypes.length + 1];
		
		System.arraycopy(argTypes, 0, newArgTypes, 1, argTypes.length);
		newArgTypes[0] = ArgType.Str_INT;
		
		info.setArgTypes(newArgTypes);
		
		String[] argValues = info.getArgValues();
		String[] newArgValues = new String[argValues.length + 1];
		
		System.arraycopy(argValues, 0, newArgValues, 1, argValues.length);
		newArgValues[0] = Integer.toString(binOpID);
		
		info.setArgValues(newArgValues);
		
		ARClassInfo i = ARClassDatabase.getSingleton().getARClassInfo(ArgType.BINARY_OPERATOR_OBJECT_CLASS_NAME);	
		info.setClassInfo(i);
		
		return;
	}
	

	/**
	 * builds the internal model of the objects and the connections.
	 * The loadbang and polling objects will be placed in the head of the global array
	 * of the objects.
	 * @param objects
	 * @param connections
	 */
	public void buildModel(Vector<ARInstanceInfo> objects, Vector<ARConnectionInfo> connections)
	{
		//--------------------------------------------------------------
		//reset instance fields.
		seqObjectID = 0;
		
		libHeaderFilenames	= new HashSet<String>();
		libCppFilenames		= new HashSet<String>();
		
		idToInstanceInfo 	= new HashMap<Integer, ARInstanceInfo>();		
		instanceNameToID	= new HashMap<String, Integer>();
		
		seqConnectionID = 0;
		idToConnectionID = new HashMap<Integer, Integer>();
		idToConnections  = new HashMap<Integer, Vector<ARConnectionInfo> >();
		
		totalNumOfInlets = 0;
		
		structNameToCount	= new HashMap<String, Integer>();
		maxArgCount			= 0;
		
		serialInObjectFound = false;

		//--------------------------------------------------------------
		//replace the operator objects
		for (ARInstanceInfo i: objects) {
			modifyIfOperatorObject(i);
		}

		
		//--------------------------------------------------------------
		//cache the required symbol IDs for all the live objects
		resetSymIDs();
		Set<String> klazzFound = new HashSet<String>();
		for (ARInstanceInfo o : objects) {
			ARClassInfo klazzInfo = o.getARClassInfo();
			String klazzName = klazzInfo.getARClassName();
			if (klazzFound.contains(klazzName)) {
				continue;
			}
			klazzFound.add(klazzName);
			String[] symbols = klazzInfo.getRequiredSymbolIDs();
			if (symbols == null) {
				continue;
			}
			for (String sym: symbols) {
				this.addSymol(sym);
			}
		}
		
		//--------------------------------------------------------------
		//assign the object ID. this looks inefficient, but the number 
		// of objects are not so large. so no worry.

		//do we have any serial in object in the Ardestan code?
		for (ARInstanceInfo o : objects) {
			if (SERIAL_IN_CLASSNAME.equals(o.getARClassInfo().getARClassName())) {
				serialInObjectFound = true;
				break;
			}
		}
		//event scheduling objects
		numOfEventSchedulingObjects = 0;
		for (ARInstanceInfo o : objects) {
			if (o.getARClassInfo().requireScheduling()){
				idToInstanceInfo.put(seqObjectID, o);
				instanceNameToID.put(o.getInstanceName(), seqObjectID);
				seqObjectID++;
				numOfEventSchedulingObjects++;
				
				totalNumOfInlets += o.getNumOfInlets();
				incrementStructNameCount(o.getStructName());
				libHeaderFilenames	.add(o.getHeaderFilename());
				libCppFilenames		.add(o.getCppFilename());

				updateMaxArgLength(o);
			}
		}
		
		//polling objects
		numOfPollingObjects = 0;
		for (ARInstanceInfo o : objects) {
			if (o.getARClassInfo().requirePolling()){
				idToInstanceInfo.put(seqObjectID, o);
				instanceNameToID.put(o.getInstanceName(), seqObjectID);
				seqObjectID++;
				numOfPollingObjects++;
				
				totalNumOfInlets += o.getNumOfInlets();
				incrementStructNameCount(o.getStructName());
				libHeaderFilenames	.add(o.getHeaderFilename());
				libCppFilenames		.add(o.getCppFilename());

				updateMaxArgLength(o);
			}
		}

		
		//loadbang objects
		numOfLoadBangObjects = 0;
		for (ARInstanceInfo o : objects) {
			if (o.getARClassInfo().requireLoadBang()){
				idToInstanceInfo.put(seqObjectID, o);
				instanceNameToID.put(o.getInstanceName(), seqObjectID);
				seqObjectID++;
				numOfLoadBangObjects++;
				
				totalNumOfInlets += o.getNumOfInlets();
				incrementStructNameCount(o.getStructName());
				libHeaderFilenames	.add(o.getHeaderFilename());
				libCppFilenames		.add(o.getCppFilename());
				
				updateMaxArgLength(o);
			}
		}
		
		//normal objects
		for (ARInstanceInfo o : objects) {
			if (o.getARClassInfo().isNormalObject()){
				idToInstanceInfo.put(seqObjectID, o);
				instanceNameToID.put(o.getInstanceName(), seqObjectID);
				seqObjectID++;
				
				totalNumOfInlets += o.getNumOfInlets();
				incrementStructNameCount(o.getStructName());
				libHeaderFilenames	.add(o.getHeaderFilename());
				libCppFilenames		.add(o.getCppFilename());

				updateMaxArgLength(o);
			}
		}
		
		//--------------------------------------------------------------
		//bind connections to the object id.
		for (int i = 0; i < idToInstanceInfo.size(); i++){	
			ARInstanceInfo o = idToInstanceInfo.get(i);
			String objName = o.getInstanceName();
			
			idToConnectionID.put(i, seqConnectionID);

			Vector<ARConnectionInfo> c = new Vector<ARConnectionInfo>();
			idToConnections	.put(i, c);

			//this is inefficient but there are not many objects, so no worry.
			for (ARConnectionInfo info : connections) {
				//if this is not a connection from the current object, just skip it.
				if (!info.getSrc().equals(objName)){
					continue;
				}
				
				//add to the connections			
				c.add(info);	
				seqConnectionID++;
			}
		}		
		
	}
	
}
