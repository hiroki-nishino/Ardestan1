//
// arobj_uln2003.cpp
//
// generated by the Ardestan programming language : Tue Dec 03 21:29:04 CST 2019
//

#include <stdio.h>
#include <stdint.h>

#include <Arduino.h>

#include "ArdestanIDs.h"
#include "Ardestan.h"

#include "arobj_uln2003.hpp"

//----------------------------------------------------------------------------
// implementation
//----------------------------------------------------------------------------

void init_func_uln2003(
    ARObject*        self      ,
    void*            __fields__,
    uint_fast8_t     argc      ,
    ARMessageType*   argt      ,
    ARValue*         argv
)
{
    ARObjUln2003* fields = (ARObjUln2003*)__fields__;

	fields->index = -1;
	
	//check the types and values of the arguments.
    for (int8_t i = 0; i < ULN2003_NUM_OF_PINS; i++){
    	if (argt[i] != ARMessageType::INT || argv[i].i < 0 || 127 < argv[i].i){
    		return;
    	}
    }

	//remember them and set the pin to the digital output mode
    for (int8_t i = 0; i < ULN2003_NUM_OF_PINS; i++){
    	fields->pins[i] = (int8_t)argv[i].i;    	
    	pinMode(fields->pins[i], OUTPUT);
    }

	//clear index.
    fields->index = ULN2003_NUM_OF_PINS - 1;

    return;
}

void trigger_func_uln2003(
    ARObject*        self      ,
    int32_t          inlet_no  ,
    void*            __fields__
)
{
    ARObjUln2003* fields = (ARObjUln2003*)__fields__;

	
    if (self->getInputType(0) != ARMessageType::SYM_ID){
    	return;
    }

   	ARSymID sym = self->getInputSymbol(0);
   	if (sym != ID_LEFT && sym != ID_RIGHT){
   		return;
   	}

	//inc/dec the index to the orientaiton.
	fields->index += (sym == ID_LEFT ? 1 : -1);
	fields->index = fields->index < 0 ? fields->index + ULN2003_NUM_OF_PINS : fields->index % ULN2003_NUM_OF_PINS;

	//rotate to the next position
	for (int8_t i = 0; i < ULN2003_NUM_OF_PINS; i++){
		digitalWrite(fields->pins[i], i == fields->index ? HIGH : LOW);
	}


    return;
}
