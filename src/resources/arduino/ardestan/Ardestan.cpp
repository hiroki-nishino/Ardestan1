//
//  Ardestan.c
//  Ardestan
//
//  Created by Hiroki NISHINO on 10/30/18.
//  Copyright Â© 2018 Hiroki Nishino. All rights reserved.
//
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <stdint.h>
#include <time.h>

#ifdef USE_PROGMEM_FOR_CONNECTIONS
#include <avr/pgmspace.h>
#else
	#ifdef USE_PROGMEM_FOR_OUTLETS
#include <avr/pgmspace.h>
	#endif
#endif
#include "ArdestanIDs.h"
#include "AutoGeneratedHeader.h"
#include "Ardestan.h"

//----------------------------------------------------------------------------
// static global
//----------------------------------------------------------------------------
static uint16_t call_depth;
static uint32_t current_time;

//----------------------------------------------------------------------------
// inline functions
//----------------------------------------------------------------------------


uint32_t now(void)
{
    return current_time;
}
void set_now(uint32_t time)
{
    current_time = time;
}

inline uint16_t reset_call_depth(void)
{
    return call_depth;
}
inline uint16_t inc_call_depth(void)
{
	call_depth++;
	if (call_depth > 255){
		panic("call-depth too deep.");
	}
    return call_depth;
}

inline uint16_t dec_call_depth(void)
{
    return --call_depth;
}

//----------------------------------------------------------------------------
// ARObject
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
/**
 @brief initialize this object
 
 @param[in] fields  the data structure that holds the object-level variables.
 @param[in] triggered_func the function that is called when triggered.
  */
//----------------------------------------------------------------------------
void ARObject::init (void*                    fields          ,
                     __AR_TRIGGERED_FUNC_PT__ triggered_func  ,
                     int32_t                  num_inlets      ,
                     ARValue*                 inlets          ,
                     bool                     only_leftmost_inlet_is_hot)

{
    assert(num_inlets <= AROBJECT_MAX_NUM_INLETS);
    
    //initialize the instance fields.
    this->fields            = fields;
    this->triggered_func    = triggered_func;
    
    this->inlets = inlets;
    this->io_info.only_leftmost_inlet_is_hot = only_leftmost_inlet_is_hot ? 1 : 0;
    return;
}

//----------------------------------------------------------------------------
/**
 @brief called when the object received something at its zero-th inlet.
        this function calls the user object's function
 
 */
//----------------------------------------------------------------------------
void ARObject::trigger(int32_t inlet_no)
{
    this->triggered_func(this, inlet_no, this->fields);
    return;
}


//----------------------------------------------------------------------------
/**
 @brief output the message from the outlet of the object.
 
 @param[in] outlet_no   the outlet no.
 @param[in] type        type of the message.
 @param[in] value       the value to be sent out
 
 */
//----------------------------------------------------------------------------
void ARObject::output(uint_fast8_t  outlet_no       ,
                      ARMessageType type            ,
                      ARValue       value           )
{
    if (outlet_no < 0){
        return;
    }
    uint16_t    id      = object_pt_to_object_id(this   );
    AROutlets   outlets = object_id_to_outlets  (id     );
    
    uint16_t lim = outlets.connection_id + outlets.num_of_connections;
    for (uint16_t i = outlets.connection_id; i < lim; i++){
        ARConnection c = connection_id_to_connection(i);
        if (c.outlet_no == outlet_no){
            ARObject* p = object_id_to_object_pt(c.dest_obj_id);
            inc_call_depth();
            p->input(c.inlet_no, type, value);
            dec_call_depth();
        }
    }
    
    return;
}
//----------------------------------------------------------------------------
/**
 @brief output the message from the outlet of the object.
 
 @param[in] outlet_no   the outlet no.
 @param[in] value       the value to be sent out
 
 */
//----------------------------------------------------------------------------
 void ARObject::outputFloat(int32_t outlet_no, float value)
{
    ARValue v;
    v.f = value;
    this->output(outlet_no, ARMessageType::FLOAT, v);
    return;
}
//----------------------------------------------------------------------------
/**
 @brief output the message from the outlet of the object.
 
 @param[in] outlet_no   the outlet no.
 @param[in] value       the value to be sent out
 
 */
//----------------------------------------------------------------------------
void ARObject::outputInt(int32_t outlet_no, int32_t value)
{
    ARValue v;
    v.i = value;
    this->output(outlet_no, ARMessageType::INT, v);
    return;
}
//----------------------------------------------------------------------------
/**
 @brief output the message from the outlet of the object.
 
 @param[in] outlet_no   the outlet no.
 @param[in] value       the value to be sent out
 
 */
//----------------------------------------------------------------------------
void ARObject::outputSymbol(int32_t outlet_no, ARSymID value)
{
    ARValue v;
    v.sym_id = value;
    this->output(outlet_no, ARMessageType::SYM_ID, v);
    return;
}
//----------------------------------------------------------------------------
/**
 @brief output the message from the outlet of the object.
 
 @param[in] outlet_no   the outlet no.
 @param[in] value       the value to be sent out
 
 */
//----------------------------------------------------------------------------
void ARObject::outputString(int32_t outlet_no, ARStr* value)
{
    ARValue v;
    v.str = value;
    this->output(outlet_no, ARMessageType::STRING, v);
    return;
}
//----------------------------------------------------------------------------
/**
 @brief update the value at the given inlet no.
 
 @param[in] inlet_no    the outlet no.
 @param[in] type        type of the message.
 @param[in] value       the value of the message.
 
 */
//----------------------------------------------------------------------------
void ARObject::setInletValue    (int32_t        inlet_no    ,
                                 ARMessageType  type        ,
                                 ARValue        value       )
{
	bool prevIsString = false;
	
    //retain the message type.
    switch(inlet_no)
    {
        case 0:
        	//if the value is string, set the flag on.
        	if (this->io_info.input0_type == ARMessageType::STRING){
        		prevIsString = true;
        	}
            this->io_info.input0_type = type;
            break;

        case 1:
        	//if the value is string, set the flag on.
        	if (this->io_info.input1_type == ARMessageType::STRING){
        		prevIsString = true;
        	}
            this->io_info.input1_type = type;
            break;

        case 2:
        	//if the value is string, set the flag on.
        	if (this->io_info.input2_type == ARMessageType::STRING){
        		prevIsString = true;
        	}
            this->io_info.input2_type = type;
            break;

        case 3:
        	//if the value is string, set the flag on.
        	if (this->io_info.input3_type == ARMessageType::STRING){
        		prevIsString = true;
        	}
            this->io_info.input3_type = type;
            break;

        case 4:
        	//if the value is string, set the flag on.
        	if (this->io_info.input4_type == ARMessageType::STRING){
        		prevIsString = true;
        	}
            this->io_info.input4_type = type;
            break;
    }
    

    if (prevIsString){
		//first the increment the reference count to the input value,
		//then decrement the current value.
		//this order is important when these two values are the same
		//to not release the string object when it is still necessary.
    	if (type == ARMessageType::STRING){
    		this->retainString	(value.str);
    	}
		this->releaseString	(this->inlets[inlet_no].str);
    }
    this->inlets[inlet_no] = value;

    return;
}
//----------------------------------------------------------------------------
/**
 @brief receive the message at the given inlet no.
 
 @param[in] inlet_no    the outlet no.
 @param[in] type        type of the message.
 @param[in] value       the value of the message.
 
 */
//----------------------------------------------------------------------------
void ARObject::input(int32_t        inlet_no    ,
                     ARMessageType  type        ,
                     ARValue        value       )
{
    //neglect an invalid inlet no.
    if (inlet_no < 0 || inlet_no >= AROBJECT_MAX_NUM_INLETS){
        return;
    }
    
    //update the inlet value.
    this->setInletValue(inlet_no, type, value);
    
    //if it is the left most inlet, just trigger this object to call
    //the object's function.
    if (inlet_no == 0 || this->io_info.only_leftmost_inlet_is_hot == false){
        this->trigger(inlet_no);
    }
    return;
}
//----------------------------------------------------------------------------
/**
 @brief receive the message at the given inlet no.
 
 @param[in] inlet_no    the inlet no.
 
 @return the type of the input value
 */
//----------------------------------------------------------------------------
ARMessageType ARObject::getInputType(int32_t inlet_no)
{
    if (inlet_no < 0 || inlet_no >= AROBJECT_MAX_NUM_INLETS){
        return INT;
    }
    uint_fast8_t t = 0;
    switch(inlet_no){
        case 0:
            t = this->io_info.input0_type;
            break;
        case 1:
            t = this->io_info.input1_type;
            break;
        case 2:
            t = this->io_info.input2_type;
            break;
        case 3:
            t = this->io_info.input3_type;
            break;
        case 4:
            t = this->io_info.input4_type;
            break;
    }
    
    switch(t){
        case 0:
        default:
            return INT;
        case 1:
            return FLOAT;
        case 2:
            return SYM_ID;
        case 3:
            return STRING;
    }
    
}
//----------------------------------------------------------------------------
/**
 @brief receive the message at the given inlet no.
 
 @param[in] inlet_no    the outlet no.
 */
//----------------------------------------------------------------------------
ARValue ARObject::getInput(int32_t inlet_no)
{
    if (inlet_no < 0 || inlet_no >= AROBJECT_MAX_NUM_INLETS){
        ARValue v;
        v.i = 0;
        return v;
    }
    
    return this->inlets[inlet_no];
}
//----------------------------------------------------------------------------
/**
 @brief receive the message at the given inlet no.
 
 @param[in] inlet_no    the outlet no.
 */
//----------------------------------------------------------------------------
int32_t ARObject::getInputInt(int32_t inlet_no)
{
    if (inlet_no < 0 || inlet_no >= AROBJECT_MAX_NUM_INLETS){
        return 0;
    }
    
    ARMessageType i = this->getInputType(inlet_no);
    switch(i){
        case SYM_ID:
        case INT:
            return this->inlets[inlet_no].i;
        case FLOAT:
            return (int)(this->inlets[inlet_no].f);
        case STRING:
            return 0;
    }
}
//----------------------------------------------------------------------------
/**
 @brief receive the message at the given inlet no.
 
 @param[in] inlet_no    the outlet no.
 */
//----------------------------------------------------------------------------
float ARObject::getInputFloat(int32_t inlet_no)
{
    if (inlet_no < 0 || inlet_no >= AROBJECT_MAX_NUM_INLETS){
        return 0;
    }
    
    ARMessageType i = this->getInputType(inlet_no);
    switch(i){
        case SYM_ID:
        case INT:
            return (float)this->inlets[inlet_no].i;
        case FLOAT:
            return this->inlets[inlet_no].f;
        case STRING:
            return 0;
    }
}
//----------------------------------------------------------------------------
/**
 @brief receive the message at the given inlet no.
 
 @param[in] inlet_no    the outlet no.
 */
//----------------------------------------------------------------------------
ARSymID ARObject::getInputSymbol(int32_t inlet_no)
{
    if (inlet_no < 0 || inlet_no >= AROBJECT_MAX_NUM_INLETS){
        return ID_INVALID_SYMBOL;
    }
    
    ARMessageType i = this->getInputType(inlet_no);
    switch(i){
        case SYM_ID:
            return this->inlets[inlet_no].sym_id;
        case INT:
        case FLOAT:
        case STRING:
            return ID_INVALID_SYMBOL;
    }
}
//----------------------------------------------------------------------------
/**
 @brief receive the message at the given inlet no.
 
 @param[in] inlet_no    the outlet no.
 */
//----------------------------------------------------------------------------
ARStr* ARObject::getInputString(int32_t inlet_no)
{
    if (inlet_no < 0 || inlet_no >= AROBJECT_MAX_NUM_INLETS){
        return NULL;
    }
    
    ARMessageType i = this->getInputType(inlet_no);
    switch(i){
        case SYM_ID:
        case INT:
        case FLOAT:
            return NULL;
        case STRING:
            return this->inlets[inlet_no].str;
    }
}


//----------------------------------------------------------------------------
/**
 @brief schedule a timer callback event.
 
 @param[in] delay the delay time
 @param[in] mode ARTimerCallbackScheduleMode
 
 @return 0 if failed. non-zero if successful.
 */
//----------------------------------------------------------------------------

uint8_t ARObject::scheduleTimerCallback(int32_t delay, ARTimerCallbackScheduleMode mode)
{
    uint16_t object_id = object_pt_to_object_id(this);
    
    if (object_id >= NUM_OF_EVENT_SCHEDULING_OBJECTS){
        return 0;
    }
    
    uint32_t time = now() + delay;
    
    //the time is scheduled after the system halt, don't schedule it.
    if (time < now()){
        return 0;
    }
    
    switch(mode){
        case SCHEDULE_IF_CLOSER:
            if (g_timer_callback_timestamp[object_id] < time){
                return 0;
            }
            
        case OVERWRITE:
            g_timer_callback_timestamp[object_id] = time;
            break;
    }
    
    return 1;
}
//----------------------------------------------------------------------------
/**
 @brief stop timer callback.
 
 @return 0 if failed. non-zero if successful.
 */
//----------------------------------------------------------------------------
uint8_t ARObject::stopScheduledTimerCallback(void)
{
    uint16_t object_id = object_pt_to_object_id(this);

    if (object_id >= NUM_OF_EVENT_SCHEDULING_OBJECTS){
        return 0;
    }
    
    g_timer_callback_timestamp[object_id] = __UINT32_MAX__;
    return 1;
}
//----------------------------------------------------------------------------
/**
 @brief create a string object
 
 @return the new string object
 */
//----------------------------------------------------------------------------
ARStr* ARObject::createString(const char* s, uint32_t initial_ref_cnt)
{
	ARStr* p = (ARStr*)malloc(sizeof(ARStr));
	if (p == NULL){
		panic("ARObject::createString: not enough memory");
	}
	
	
	//initialize the ARStr object
	p->ref_cnt 	= initial_ref_cnt;
	p->p		= s;
	
	return p;
}

//----------------------------------------------------------------------------
/**
 @brief retain the string object (increment the ref count)
 
 @return the string object
 */
//----------------------------------------------------------------------------
ARStr* ARObject::retainString(ARStr *str)
{
	if (str == NULL){
		return NULL;
	}
	str->ref_cnt += str->ref_cnt < STRING_REF_CNT_MAX ? 1 : 0;

	return str;
}
//----------------------------------------------------------------------------
/**
 @brief release the object (decrement the ref count. if this is the last
        reference to the object, release the object)
 
 @return the string object. If the object was released, it returns NULL.
 */
//----------------------------------------------------------------------------
ARStr* ARObject::releaseString(ARStr *str)
{
	if (str == NULL){
		return NULL;
	}

	if (str->ref_cnt >= STRING_REF_CNT_MAX){
		return str;
	}
	
	str->ref_cnt--;

	if (str->ref_cnt == 0){
		free((void*)str->p);
		free((void*)str);
		return NULL;
	}
	return str;
}
//----------------------------------------------------------------------------
//  id <- -> object
//----------------------------------------------------------------------------

//----------------------------------------------
// object pointer to object id
uint16_t object_pt_to_object_id(ARObject *object)
{
    return ((uint8_t*)object - (uint8_t*)g_objects) / sizeof(ARObject);
}

//----------------------------------------------
// object id to object pointer
ARObject* object_id_to_object_pt(uint16_t object_id)
{
    return &(g_objects[object_id]);
}

//----------------------------------------------
// object id to outlets
AROutlets object_id_to_outlets(uint16_t object_id)
{
#ifdef USE_PROGMEM_FOR_OUTLETS
	union {
		uint16_t i;
		AROutlets o;
	} v = { pgm_read_word(g_outlets + object_id) };
	return v.o;
#else
    return g_outlets[object_id];
#endif
}

//----------------------------------------------
// connection id to connection
ARConnection connection_id_to_connection(uint16_t connection_id)
{
#ifdef USE_PROGMEM_FOR_CONNECTIONS
	union {
		uint16_t i;
		ARConnection c;
	} v = { pgm_read_word(g_connections + connection_id)};

	return v.c;
#else
    return g_connections[connection_id];
#endif
}

//----------------------------------------------
//schedule a timer callback event.
uint32_t process_scheduled_timer_callback(uint32_t upper_limit)
{
    uint32_t current_time = now();
    if (current_time == __UINT32_MAX__){
        return current_time;
    }
 
    ARValue v;
    v.sym_id = ID_TIMER_CALLBACK;

    while(true){

        assert(NUM_OF_EVENT_SCHEDULING_OBJECTS > 0);
        
        int min_idx = 0;
        uint32_t min_sched_time = g_timer_callback_timestamp[0];
        for (int i = 1; i < NUM_OF_EVENT_SCHEDULING_OBJECTS; i++){
            if (g_timer_callback_timestamp[i] < min_sched_time){
                min_sched_time = g_timer_callback_timestamp[i];
                min_idx = i;
            }
        }
        
        //no event scheduled.
        if (min_sched_time > upper_limit || min_sched_time == __UINT32_MAX__){
            set_now(upper_limit);
            return upper_limit;
        }
        
        //update the current time.
        set_now(min_sched_time);
        g_objects[min_idx].input(0, ARMessageType::SYM_ID, v);
        current_time = min_sched_time;
    }

    return upper_limit;
}
//----------------------------------------------------------------------------
//  panic
//----------------------------------------------------------------------------
uint8_t g_panic_mode = ARPanicMode::BLINK_LED_BUILTIN;

void panic(const char* message)
{
	switch(g_panic_mode){
	case SERIAL_OUTPUT_MESSAGE:
		while(true){
			Serial.begin(9600);
			Serial.println(message);
			delay(3000);
		}
	case BLINK_LED_BUILTIN:
		pinMode(LED_BUILTIN, OUTPUT);
		while(true){
			digitalWrite(13, HIGH);
			delay(1000);
			digitalWrite(13, LOW);
			delay(1000);
		}
	
	default:
	case JUST_HALT:
		while(true){
			delay(1000);
		}
	}
}
